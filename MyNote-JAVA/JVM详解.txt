JVM：即是java Virtual Machine（java虚拟机），

	1，JVM的生命周期：（有几个main函数被启动，就启动了几个java虚拟机
		-启动：当启动一个java程序时，一个jvm实例就产生了 
			任何一个public static void main(String[] args)函数都可以成为jvm运行的起点
		-运行：main（）作为该程序初始线程的起点，其他线程都由该线程启动
		-消亡：当程序中的所有非守护线程都终止了，jvm就退出了；若安全管理器允许，也可以使用
			Runtime或者System.exit()类退出
			
			java的线程有两种：守护线程和普通线程。守护线程就是java虚拟机自己使用的线程，比如
		GC线程，当然也可以直接将线程设置为守护线程

	GC垃圾回收机制：不是当那个创建的变量为空即回收，而是当变量超出了其作用域将其回收
	2，程序在JVM运行的流程：
		当一个程序运行前，其class会被 类加载器 装入 方法区 ， 执行引擎 读取方法区的字节码自适应
		解析，边解析边运行，然后pc寄存器(程序计数器)指向main函数所在的位置，虚拟机为main函数在
		java栈 中预留一个栈帕(每个方法都有一个栈帧)，运行主方法后，main中的代码被执行引擎映射到
		本地操作系统里对象的实现，如果调用 本地方法接口 ，本地方法运行时，OS会为本地方法分配
		本地方法栈 ，用来存储一些临时变量，之后运行本地方法，调用OS的API等。
		
	3，jav运行时数据区：
		1，程序计数器（PC寄存器）：指向当前线程正在执行的字节码指令，线程私有。
		2，java虚拟机栈：是java执行方法的内存模型。每个方法执行的时候都会创建一个栈帧，将栈帧挤压入
			栈，当方法正常返回或抛出未捕获的异常时，栈帧都会出栈。其是线程私有的。
			①：栈帧：其中存储方法的相关信息
				局部变量表：包含了方法执行过程中的所有变量，局部变量数组所需空间在编译期间分配完成
				操作数栈：操作变量的内存模型。其最大深度在编译期就确定(写入方法区code属性的max_stacks中)
					其中的元素可以是任意的java类型，32位数据占用栈空间为1,64位数据为2.方法刚开始执行时
					操作数栈是空的，方法执行过程中，各种字节码指令向栈中存取数据。
				返回值：若有返回值，则将其压入到调用者的栈帧中的操作数栈中，并将pc值指向下一条指令的地址
				动态链接：每个栈帧都持有在运行时常量池中该栈帧所属方法的引用，用于在需要调用该方法时能够
					正确的找到其在方法区中常量池的数据。
		3，本地方法栈：
			用于调用本地native的内存模型，本地方法是指方法中带有native修饰符的方法，其表示这个方法的实现
			不是通过java代码来实现的。其作用和java虚拟机栈类似，不过它是为native方法服务。其也是线程私有的。
		4，方法区：
			在虚拟机启动的时候创建，是所有线程共享的
			用来存储已被虚拟机加载的类信息（永久代），常量，静态常量，即时编译后的机器指令集等数据
			运行时常量池：用于存放编译期生成的各种字面量和符号 的引用，在类加载之后就进入
				该引用用于和局部变量进行沟通等。
			
		5，程序计数器(pc寄存器)：
			①：是一块很小的内存空间，是当前线程所执行的字节码的行号指示器，线程私有。
			②：是jvm中唯一一个没有规定OutOfMemoryError情况的区域，因为其中只存储一行数字（最少32位
			③：计算机硬件中的pc寄存器存放“伪指令”或地址，而虚拟机中pc存放下一条指令的地址
			④：当程序执行的是一个native方法时，计数器中存储的值为空(undefined,未定义)
			
		6，java堆(Heap):
			①：其是jvm所管理的内存中最大的一块，物理存储上不连续，逻辑连续的大小可调(-Xms,-Xmx)
			②：其是所有线程共享的
			③：在虚拟机启动时才创建
			④：此内存用于存放对象实例，几乎所有的对象实例都在这里分配内存，存放new生成的对象和数组
			⑤：java堆是垃圾收集器管理的主要区域，也被称为“GC堆”
			
		7，GC垃圾回收机制：基于java堆和方法区
			①， 新生代是类的诞生，成长，消亡的区域，一个Eden区和两个Survivor区，默认比例8:1：！
				Eden区：新创建的对象（new）一般都在这里(一些大对象特殊处理)，当Eden区满了之后。
				程序又需要创建新对象，知识会进行Minor GC垃圾回收，将Eden中幸存下的对象移入From中
				若Survivor(From)也满了，则将存活下来的对象移入Survivor(To)中，（即Survivor1和2区）
				在将对象进入到2区(To)中之前会进行严格年龄判断(年龄阈值，通过XX:MaxTenuringThreshold设置)
				若达到阈值则进入老年代，否则进入To区，(动态判断，若相同年龄的对象的大小大于Survivor的一半
				，则年龄大于该年龄的对象也会直接进入老年代)，From区和To区会来回互换身份，直到To区也满了之后，
				会将所有对象直接送到老年代。
			②： Minor GC：清理新生代，当Eden区满时
				Major GC：清理老年代，是否停止了所有应用程序的线程
				Full GC：清理整个堆空间，包括新生代和老年代，
					调用System.gc时；老年代空间不足；方法区空间不足；
			③： 永久代：存储在方法区中，不在java堆中，主要是存储Class和Mate(元数据)等信息
					在class被加载的时候就被放入了永久区，不会在程序运行时对永久区清理，所以可能会
					随着加载的class的增多而OOM(OutOfMemoryError)异常.
					 所以，在jdk8中，永久代被元数据区(元空间，MateSpace)取代了,其本质不变，不过元空间
					不在java虚拟机，而是使用了本地内存，就不会出现OOM异常
					
	4，线程问题：java堆和方法区是所有线程共享的区域，不同线程公用一个
		虚拟机栈，本地方法栈，程序计数器都是线程独享的，即一个线程就会有一个
					 
	5，类加载机制：类加载器将class文件的二进制数据读入到内存中，存放在方法区，如何在堆去创建一个
				java.lang.Class对象，用来封装类在方法区中的数据结构
			先自底层向上检验类是否被加载，再从顶向下的进行对类的加载
				1）Bootstrap ClassLoader(上层，顶)
					是jvm的根ClassLoader，由c++实现，加载核心API,加载$JAVA_HOME中jre/lib/rt.jar中的所有class
					文件这个jar包包含了java规范定义的所有接口及其实现，jvm启动时就开始初始化ClassLoader
				2）Extension ClassLoader
					加载java扩展API(lib/ext中的类)
				3）App ClassLoader
					加载Classpath目录下定义的class
				4）Custom ClassLoader
					属于应用程序根据自身需要定义的ClassLoader，
					编写：继承ClassLoader，重写findClass方法，从特点位置加载class文件，得到字节数组，如何利用
						defineClass将字节数组转化为Class对象，一般用于对代码进行加密
			双亲委派机制：
				在一个类加载器收到类加载请求是，它首先会先将加载任务委托给父类加载器，若父类可以完成任务，
				则就不需要再次加载，若父类无法完全加载，子类加载器才回去自己加载。都无法架子，则ClassNotFind异常
				意义：避免重复加载；更安全，保证了类的唯一性，；
	
	6，JVM优化：
		1）一般而言，当survivor区不够大或者占用量达到50%时，就会将一些对象放到老年代，通过设置合理的eden区，
			survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用（-Xmn）设置年轻代的大小
		2）对于占用内存较多的大对象，一般会分配在老年代。通过设置参数（-XX:PetenureSizeThreshold=1000000）,
			单位为B，表示对象大小超过1M时，直接将对象分配在老年代
		3）一般年轻对象放在eden区，第一次GC后，若对象还存活，则放到survivor区，之后，每一次GC对象的年龄+1
			当对象的年龄达到阈值，就放到老年区。可以通过设置（-XX:MamTenuringThreshold）改变这个阈值
		4）设置最小堆和最大堆：-Xmx和-Xms稳定的堆大小对垃圾回收是有利的，将最大和最小值设置为一样，则可以减少
			GC次数。不过会增加每次GC的时间，因为每次GC都要把堆的大小维持在一个区间内
		5）一个不稳定的堆也不是一无是处。当系统不需要使用大内存时，压缩堆空间，使得GC没猜错应对一个较小的堆空间
			加快单词GC次数。
			①-XX:MinHeapFreeRation :用于设置堆空间的最小空闲笔录，默认40，即空闲内存比率小与40，jvm就会扩展堆空间
			②-XX:maxHeapFreeRation :设置堆空间最大空闲比率，默认70，若空闲内存大于70%，则jvm会压缩堆空间
			③ 当-Xms和-Xmx一致时以上两个参数无效
		6）通过增大吞吐量提高系统性能，可以通过设置并行垃圾回收收集器。
			①：-XX:+UseParallelGC:年轻代使用并行垃圾回收收集器。这是一个关注吞吐量的收集器，可以尽可能的减少垃圾回收时间。
			②：-XX:+UseParallelOldGC:设置老年代使用并行垃圾回收收集器
		7）尝试使用大的内存分页：使用大的内存分页增加CPU的内存寻址能力，从而提高系统的性能。
			-XX:+LargePageSizeInBytes 设置内存页的大小
		8）使用非占用的垃圾收集器。-XX:+UseConcMarkSweepGC老年代使用CMS收集器降低停顿。
		9）-XXSurvivorRatio=3，表示年轻代中的分配比率：survivor:eden = 2:3
		10）JVM性能调优的工具：
			①，jps（Java Process Status）：输出JVM中运行的进程状态信息(现在一般使用jconsole)
			②，jstack：查看java进程内线程的堆栈信息。
			③，jmap：用于生成堆转存快照
			④，jhat：用于分析jmap生成的堆转存快照（一般不推荐使用，而是使用Ecplise Memory Analyzer）
			⑤，jstat是JVM统计监测工具。可以用来显示垃圾回收信息、类加载信息、新生代统计信息等。
			⑥，VisualVM：故障处理工具
			
			