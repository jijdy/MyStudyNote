## synchronized
	1. 只能修饰对象，锁方法是使用了锁对象的思想
	2. 相当于为其修饰和的对象或方法加了锁
	3. 时间片的切换可以发生在一个操作未完成时，所以若在一个锁对象发生上下文切换时操作未完成，但仍有锁，对该对象的操作的其余线程仍然还是处于block状态，能得到时间片的只能是其余不对这个已经被加了锁的对象进行操作的线程或者得到了这个锁的线程。即保证了操作的完整性和原子性
	4. 对象的操作：synchronized (锁住的对象) {进行的操作/临界区}，通过锁住多个线程进行的同一个操作对象可以保证原子性
	5. 方法的操作：
	~~~
	public synchronized void method() {操作} 
	//等价于
	public void method() {synchronized(this){ 操作} } 
	
	//对方法加锁时，就是调用this(方法所在对象)将同步操作放在对象上
	//若方法为静态static方法，因为静态方法作用域整个类，所以调用 synchronized(对象名.class) {}对该类全部进行加锁操作，锁住的是整个类
	
	// this和.class所调用的对象不是同一个，.class表示原生类对象，this表示之后方法所在的new出来对象
	~~~
	6. 不加sychronized的方法不遵守锁规定，其操作仍然不是原子性的
	
	
## 变量的线程安全
	1. 若成员变量和静态变量没有被共享，则不会有线程不安全，但若涉及到了多个线程的读写操作，则应该考虑其线程安全问题
	2. 局部变量是线程安全的，但若局部变量引用的对象会跳出其作用范围，(return出去)，也不是安全的
	3. 一般局部变量被多个线程引用，会在栈帧中分别创建不想关的方法，在执行玩操作之后就会释放，不会有线程安全的问题
	4. 若两个局部变量中调用了一个共享的对象，则还是会有线程安全问题
	5. 没有共享资源，就没有伤害！！
	
## 常见的线程安全类
	1. String
	2. Integer
	3. StringBuffer
	4. Random
	5. Vector（）
	6. HashTable
	7. java.util.concurrent下的包