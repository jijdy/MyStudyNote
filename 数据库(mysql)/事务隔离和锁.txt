1，事务的特性：
	原子性： 事务是最小的执行单位，不允许分割。
	一致性： 执行事务前后，数据保持一致，
	隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，
	持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，

2，并发事务中的问题：
	1）脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，
		而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，
		然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务
		读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
	2）丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问
		了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。
		这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中
		的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，
		事务1的修改被丢失。
	3）不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，
		另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改
		导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样
		的情况，因此称为不可重复读。
	4）幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，
		接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现
		多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读

3，事务隔离级别：
	1）READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，
		可能会导致脏读、幻读或不可重复读。
	2）READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，
		但是幻读或不可重复读仍有可能发生。
	3）REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是
		被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
	4）SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务
		依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止
		脏读、不可重复读以及幻读。

4，事务的使用：
	Start transaction ;(begin;) //显式的开启一个事务，使得之后的sql语句具有事务的特性
	  一系列的sql语句；
	commit; 提交事务，使得sql语句对数据库的修改变为永久性的
	rollback； 回滚，在提交事务前使用，可将数据库回复到开启事务的状态

5，锁在事务中的使用：
	表锁：将数据库中一张表整体的锁住
	GAP/隔离锁：将多个连续的行锁住
	行锁；只锁住了表中的一行数据

	Innodnb 在一个事务对一个行进行操作时，会持有一个行锁，但是若使用了next-key locks
	  算法，则会在产生行锁时同时持有对一个范围的隔离锁(所调用的两个行的中间所有行)，
	  以保证在repeatable-read(可重读)隔离级别就可以防止幻读。

	在一个事务对一个行进行操作时，产生一个行锁，但同时会产生一个假表锁/意向锁，
		这个意向锁用于在其他事务对这个表进行操作时快速定位到被锁定的行。


