### 实现手段

* 首先从redis中获取数据，存储时使用json格式存储，使用redisTemplate来进行处理
* 判断redis中是否存在数据，取出的数据是否是空数据
* 若数据不存在，则从数据库中再读取
* 将读取到的数据存到redis中
* 返回数据

### 相关的问题及解决方案

#### 缓存穿透

* **概念**：一般是黑客使用的方式，使用大批量的即在缓存中查找不到的数据，也在数据库中查找不到的数据访问服务器，这样过多的无关请求，缓存就失去了其应有的意义。数据库也会有较大的压力。
* **解决方案**：
  * 使用布隆过滤器，将可能所有存在的数据请求哈希的存放到一个足够大的bitmap中，那么一定不存在的数据就会别直接过滤，不会再访问缓存或数据库。
  * 或者通过设定无效缓存，若该次访问的数据请求在数据库中也没有查找到，则在缓存中将这个数据请求写入并设为NotFound，设置失效时间。但该方法也有可能导致缓存的过度使用

#### 缓存击穿

* **概念**：当redis缓存中的某个数据是一个常被访问的热点数据，当缓存中的这个数据失效的一瞬间，会有大量的请求直接到达数据库，给数据库带来较大压力。
* **解决方案**：
  * 将热点数据设置为永不过期
  * 基于redis or zookeeper实现互斥锁，等第一个请求构建玩缓存之后才能让之后的相同请求进行数据访问，此时访问的就是redis中的缓存数据

#### 缓存雪崩

* **概念**：当redis在高峰期意外**宕机**，或者缓存中的大量数据在同时失效，用户的大量访问数据直接访问数据库，将数据库直接打死，并且在redis重新启动工做之前，数据库重启都是会直接死机，这种情况就是缓存雪崩
* **解决方案**：
  * 使用redis高可用，主从复制+哨兵，redis cluster，避免redis全面崩溃。
  * 本地使用ehcache缓存(二级缓存) + hystrix限流&降级，避免mysql直接死机
  * 为redis设置持久化，若真的宕机，重启之后可以直接运用
  * 加锁或使用队列来限制访问的并发量，
  * 将缓存的失效时间间隔开(在原本的时间上增加一个几分钟的随机值)，防止一下有过大的访问量直接到达数据库



#### 数据丢失



