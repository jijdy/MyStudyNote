1，java的解释执行：
	jvm：javac将java文件编译为class字节码文件，字节码文件通过jvm虚拟机进行逐行？解释执行，
	jit：但是考虑到完全依赖jvm运行的效率问题，jit(just in time)技术将频繁使用的字节码
		部分(热点代码)编译为本地的机器码以便提高执行速度，类似于缓存的概念，在运行时这些
		高频代码就会有很高的执行速度，而不需要再进行字节码的解释执行。
	AOT：java9中提供的可以将java文件圈闭编译为机器代码执行的编译器
	

2，Exception和Error的区别：
	两者都继承于Throwable类(Object子类)，exception是程序正常运行时可以预料的意味情况
		是可以通过抛出或捕获(catch)对其进行相应的处理。exception又分为可检查(checked)和
		不检查异常。可检查异常会在编译期就进行检查，如IOException异常
		不检查异常就是运行时异常，类似于空指针异常，数组越界异常等。
	error是在正常情况下不应该出现的错误，绝对部分的error队徽导致程序或者jvm出现不可继续运行
		的错误，不需要捕获(也无法处理)，常见的有OutOfMemoryErrot等
	

3，NoClassDefFoundError和ClassNotFoundException的区别：
	一个是错误，一个是异常。error是值一个类在编译时存在，在运行时找不到class文件
	异常时一个未找到类异常，在使用Calss.forName()方法时这个异常就是一个可检查异常，会在编译时报出
	

4，throw和throws的区别：
	throw是语句抛出一个异常，一般用在代码块的内部，在程序出现某种错误时由程序员主动抛出某种
		已知的异常。
	throws是方法可能抛出的异常，声明其可能会抛出何种异常，并将异常返回调用者处理
	

5，为什么尽量少的使用java中的异常处理机制：
	try-catch代码块会产生额外的性能开销，其在代码中的使用会影响jvm对代码的优化。
		使用try-catch语句控制代码流程，往往比使用if/else语句低效得多
	java中没实例化一个Exception对象，java虚拟机会生成该异常的栈轨迹(stack trace)
		,会对当前线程的栈帧进行快照，记录各种调试信息，包括使用的方法和调用的对象与类。


6，final，finally ，finalize的特点区别：
	final是一个关键字，用于修饰类，方法，变量。其修饰的类代表不能够被继承，变量代表不能被修改
		方法代表不能够被重写。
		在final修饰一个集合对象时，只能够保证这个对象的引用不可以被赋值，但该集合仍可以添加元素等
	finally是保证重点代码一定被执行的一种机制，多用于try-catch-finally异常处理，或进行关闭jdbc连接
		或保证unlock锁的动作。
	finalize是一个基础的object类，用于gc回收前完成对特点资源的回收，但现在已经不推荐使用。
		现在可以使用cleaner类通过幻象引用来代替finalize的作用，在对象别销毁之前完成一项资源回收的工作
		类似于关闭文件描述符等。
		
		
7，强引用，弱引用，软引用，虚引用（幻象引用）的区别，和实现：
	在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，
	将引用分为4类。

	1 强引用
		特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象
		所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），
		使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象
		，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，
		就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。

	2 软引用
		特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时
		，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象
		。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，
		Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法
		来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个
		Reference对象。

		应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉
		，这样就保证了使用缓存的同时，不会耗尽内存。

	3 弱引用
		弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域
		的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器
		是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）
		联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

		应用场景：弱应用同样可用于内存敏感的缓存。

	4 虚引用
		特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。
		幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，
		那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）
		联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，
		把这个虚引用加入到与之关联的引用队列中。
			ReferenceQueue queue = new ReferenceQueue ();
			PhantomReference pr = new PhantomReference (object, queue);
		程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。
		如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些
		程序行动，例如关闭流操作或jdbc连接等。

		应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知
		

8，java中字符串Stirng,StringBuffer,StringBuilder的区别和应用场景：
	  String为什么被设计为final类：
		  保证线程安全和安全，在hashmao中使用作为key，或作为数据库或接口的参数
		  通过字符串池可以节省空间，每个String对应一个hash值，再次使用不需要重新计算
	
	String ：由于字符串在编程中的大量使用，java为了提高内存的利用效率，引入了字符串常量池的概念，在创建一个字符串时
		如果池中有equal()方法判断相等的字符串对象，则直接进行引用。若池中无，则创建对象并将对象放入到常量池中。
		但是通过new的方式创建的Stirng对象时通过对象的创建流程直接在堆区或栈去创建新的对象，而不会进行字符串池的检查
			String str1 = "123"; //通过直接赋值的方式，会有对字符串池的操作
			String str2 = new String("123"); //不会检查字符串常量池的数据，也不会放入池中
		String提供了inter()方法。调用该方法时，如果常量池中包括了一个等于此String对象的字符串（由equals方法确定），
		则返回池中的字符串。否则，将此String对象添加到池中，并且返回此池中对象的引用。
		
		String类底层使用char数组/byte数组实现，并将String类进行了final修饰。所以String对象一旦创建，那么久不能对它
		进行改变(大小，内容)，用以保证了多线程中的线程安全。
	
	StringBuffer/StringBuilder:两者都是AbstartStringBuilder抽象类的实现，方法几乎一致，都是可变字符串的实现。
		底层的存储方式和String相同，不过这两者的字符串时可以改变的，不过在大小超过一个确定的默认值大小时，会进行扩容。
		但是扩容时会创建一个新的对象用于拷贝，会额外消耗资源，故一般确定大小为优。
		StringBuffer是线程安全的，其底层方法几乎使用了synchronize关键字修饰，简单粗暴
		Stringbuilder不是线程安全的，但是在单机情况下回有更高的效率。
		
	应用场景：
	[A]在字符串内容不经常发生变化的业务场景优先使用String类。例如：常量声明、少量的字符串拼接操作等。如果有大量的字符串
		内容拼接，避免使用String与String之间的“+”操作，因为这样会产生大量无用的中间对象，耗费空间且执行效率低下
		（新建对象、回收对象花费大量时间）。
	[B]在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在多线程环境下，建议使用StringBuffer，例如XML解析、
		HTTP参数解析与封装。
	[C]在频繁进行字符串的运算（如拼接、替换、删除等），并且运行在单线程环境下，建议使用StringBuilder，例如SQL语句拼装、
		JSON封装等。