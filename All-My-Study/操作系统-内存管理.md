## 内存管理

#### 虚拟内存

* 使用虚拟内存使得物理内存能够扩充为更大的逻辑内存。可以使内存的存储结构为不连续的。
* 操作系统价格内存抽象为地址空间，每个程序又自己的地址空间，地址空间被分为很多页，这些页被映射到物理内存中，但不全部都存在于物理内存中。在程序运用到了不在物理内存中的页时，由硬件去执行必要的映射，将需要的页加载到物理内存中。
* 通过虚拟内存的形式，在一个小内存的操作系统中运行被其内存更大的程序，通过虚拟内存映射，不需要将全部的程序所需内存一次性加载到物理内存，而是在需要时加载。

#### 分页系统地址映射

* 内存管理系统(MMU)管理地址开年和物理内存将的映射，其中的**页表**存储者页(程序的地址空间)和页框(物理内存空间)的映射表
* 一个虚拟地址有页面量和偏移量，
* 分页所分出的页都是相同大小的页，

#### 页面置换算法

* 因为分页的关系，在每次访问到了物理内存中没有的资源时，发生缺页，需要进行页面置换，若此时物理内存中没有足够的内存来放置虚拟内存的分页，则需要将物理内存中已经存在的页面置换出去。
* 页面置换算法和缓存淘汰策略类似，都是需要为新来的数据腾出空间来。
* 页面置换算法的主要目标就是使得页面置换频率最低(缺页率最低)。

1. **最佳**：所替换出去的页是之后最长时间不被再次访问的，通常可以保证最低的缺页率。但这知识理论上的算法，谁也不知道之后要访问的页面是哪个。
2. **最近最久未使用**：通过维护一个拥有所有页面的链表，当页面被访问时，将改页面所属链表数据放到表头/尾，则处于表尾/头的页面就是最久未被使用的。但是每次访问都需要维护更新链表，开销较大。
3. **最近未使用**：通过两个标记位，被使用和被修改，使用未定时清零，此算法会优先换出已经被修改但最近未使用的脏页面。
4. **先进先出**：字面意思，一般不会采用。
5. **第二次机会算法**：通过维护一个优先链表和设置访问标志位来实现，当页面需要置换时，找到最老的页面，若该页面的最近未被访问，则替换，若有访问，则将改页面放置的链表头表示为新加入的页面。
6. **时钟**：在第二次机会算法的基础上进行改进，将进行存储的链表连成环，用一个指针指向最老的页面。

#### 分段

* 也可以说是分表技术，将页表分为多个页面大小不同的段，这样可以避免数据增长过多导致的覆盖问题。
* 使用段页式技术，可以在兼顾获得分页系统更大的地址空间的同时，同时有分段系统的数据共享和保护
